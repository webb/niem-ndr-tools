#!/usr/bin/env bash

set -o pipefail -o nounset -o errexit
unset CDPATH

#HELP:COMMAND_NAME: run tests of NDR rules found under indicated directory
#HELP:Usage: COMMAND_NAME option* $dir...
#HELP:    Default directory is "."
#HELP:Options:
#HELP:  --help | -h: print this help
#HELP:  --verbose | -v: print debugging and status output
#HELP:  --keep-temps | -k: Don't delete temporary files

root_dir=$(dirname "$0")/..
. "$root_dir"/share/wrtools-core/opt_help.bash
. "$root_dir"/share/wrtools-core/opt_verbose.bash
. "$root_dir"/share/wrtools-core/fail.bash
. "$root_dir"/share/wrtools-core/temp.bash

OPTIND=1
while getopts :hkv-: OPTION
do
    case "$OPTION" in
        h ) opt_help;;
        k ) opt_keep_temps;;
        v ) opt_verbose;;
        - )
            case "$OPTARG" in
                help ) opt_help;;
                verbose ) opt_verbose;;
                keep-temps ) opt_keep_temps;;
                help=* | verbose=* | keep-temps ) fail "No argument expected for long option \"${OPTARG%%=*}\"";;
                *=* ) fail "Unexpected long option (with argument) \"${OPTARG%%=*}\"";;
                * ) fail "Unexpected long option \"$OPTARG\"";;
            esac;;
        '?' ) fail "Unknown short option \"$OPTARG\"";;
        : ) fail "Short option \"$OPTARG\" missing argument";;
        * ) fail "bad state OPTARG=\"$OPTARG\"";;
    esac
done
shift $((OPTIND-1))

if (( $# == 0 ))
then set .
fi

exit_status=0

process_test_file () {
    printf '#############################################################################\n'
    printf '# %s\n' "$1"
    test=$1
    test_base=$(basename "$test")
    test_dir=$(dirname "$test")
    case $test_base in
        *.xsd.*.results.txt )
            # test_base = niem-core.xsd.ref.results.txt
            # part1 = niem-core.xsd.ref :
            part1=${test_base%.results.txt}
            # rule_set = ref :
            rule_set=${part1##*.}
            # subject_file_base = niem-core.xsd : 
            subject_file_base=${part1%.$rule_set}

            case $rule_set in
                ext | ref )
                    printf 'file %s -> rules %s on subject %s\n' \
                           "$test" "$rule_set" "$test_dir"/"$subject_file_base" >&2

                    if ! test-run \
                         --exit-success \
                         --exit-status=0 \
                         --stderr=/dev/null \
                         --stdout="$test" \
                         -- \
                         get-test-report --rules="$rule_set" --brief "$test_dir"/"$subject_file_base"
                    then exit_status=1
                    fi ;;
                set )
                    printf 'file %q -> rules set on subject %q with XML catalog %q \n' \
                           "$test" "$test_dir"/"$subject_file_base" "$test_dir"/xml-catalog >&2

                    if ! test-run \
                         --exit-success \
                         --exit-status=0 \
                         --stderr=/dev/null \
                         --stdout="$test" \
                         -- \
                         get-test-report --rules=set --brief --xml-catalog="$test_dir"/xml-catalog.xml \
                             "$test_dir"/"$subject_file_base"
                    then exit_status=1
                    fi ;;
                * ) fail "unknown rule set ($rule_set)" ;;
            esac ;;

        *.xml.valid.results.txt )
            # test_base = instance.xml.valid.results.txt
            # subject_file_base = instance.xml
            subject_file_base=${test_base%.valid.results.txt}

            printf 'file %q -> schema validation of subject %q with XML catalog %q\n' \
                   "$test" "$test_dir"/"$subject_file_base" "$test_dir"/xml-catalog >&2

            if ! test-run \
                 --exit-success \
                 --exit-status=0 \
                 --stderr=/dev/null \
                 --stdout="$test" \
                 -- \
                 xs-validate --catalog="$test_dir"/xml-catalog.xml "$test_dir"/"$subject_file_base"
            then exit_status=1
            fi ;;

        test.*.bash )
            printf 'file %s -> running in dir "%s"\n' "$test" "$test_dir" >&2
            pushd "$test_dir" > /dev/null
            if ! bash "$test_base"
            then exit_status=1
            fi
            popd > /dev/null
            ;;
        * ) fail "unknown test format ($test)" ;;
    esac
}
    
for path in "$@"
do if [[ -d $path ]]
   then while read -r -d ''
        do process_test_file "$REPLY"
        done < <(find "$path" -type f '(' -name '*.results.txt' -o -name 'test.*.bash' ')' -print0)
   else process_test_file "$path"
   fi
done
      
exit $exit_status


